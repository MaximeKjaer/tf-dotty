<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>Dotty features · tf-dotty</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Tf-dotty uses some new language features introduced in Dotty, as well as some extensions to Dotty."/><meta name="docsearch:language" content="en"/><meta property="og:title" content="Dotty features · tf-dotty"/><meta property="og:type" content="website"/><meta property="og:url" content="https://maximekjaer.github.io/tf-dotty/"/><meta property="og:description" content="Tf-dotty uses some new language features introduced in Dotty, as well as some extensions to Dotty."/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/tf-dotty/img/favicon.ico"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://maximekjaer.github.io/tf-dotty/blog/atom.xml" title="tf-dotty Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://maximekjaer.github.io/tf-dotty/blog/feed.xml" title="tf-dotty Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script><script src="/tf-dotty/js/scrollSpy.js"></script><link rel="stylesheet" href="/tf-dotty/css/main.css"/><script src="/tf-dotty/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/tf-dotty/"><h2 class="headerTitle">tf-dotty</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="/tf-dotty/docs/getting-started" target="_self">Docs</a></li><li class=""><a href="/tf-dotty/blog/" target="_self">Blog</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Architecture</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Getting Started</h3><ul class=""><li class="navListItem"><a class="navItem" href="/tf-dotty/docs/getting-started">Getting Started</a></li><li class="navListItem"><a class="navItem" href="/tf-dotty/docs/benchmarks">Benchmarks</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Architecture</h3><ul class=""><li class="navListItem"><a class="navItem" href="/tf-dotty/docs/architecture">Architecture</a></li><li class="navListItem navListItemActive"><a class="navItem" href="/tf-dotty/docs/dotty">Dotty features</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Implementation</h3><ul class=""><li class="navListItem"><a class="navItem" href="/tf-dotty/docs/tensor">Tensor</a></li><li class="navListItem"><a class="navItem" href="/tf-dotty/docs/reduce">Reduce</a></li><li class="navListItem"><a class="navItem" href="/tf-dotty/docs/reshape">Reshape</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Contributing</h3><ul class=""><li class="navListItem"><a class="navItem" href="/tf-dotty/docs/contributing">Contributing</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">Dotty features</h1></header><article><div><span><p>Tf-dotty uses some new language features introduced in Dotty, as well as some extensions to Dotty.</p>
<h2><a class="anchor" aria-hidden="true" id="existing-dotty-types"></a><a href="#existing-dotty-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Existing Dotty types</h2>
<h3><a class="anchor" aria-hidden="true" id="singleton-types"></a><a href="#singleton-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Singleton types</h3>
<p>Singleton types are types with a single inhabitant. Literal-based singleton types were introduced to Scala in the <a href="https://docs.scala-lang.org/sips/42.type.html">SIP-23 proposal</a>. They make it possible to type literal values as the singleton type that they are the sole inhabitant of. For instance, <code>val one: 1 = 1</code> type-checks.</p>
<h3><a class="anchor" aria-hidden="true" id="union-types"></a><a href="#union-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Union types</h3>
<p>TensorFlow's API restricts some operations to a subset of available tensor element types. For instance, <a href="https://www.tensorflow.org/versions/r1.14/api_docs/python/tf/math/minimum"><code>tf.math.minimum</code></a> can be applied to tensors of integers and of floats, but not to tensors of strings or of booleans. Note that this is a fixed constraint of the C++ implementation of TensorFlow; it would be incorrect to allow the <code>minimum</code> function to be applied whenever an implicit <code>Ordering</code> can be found, as the Scala implementation of <code>Int.min</code> does: the C++ implementation does not function with user-defined Scala <code>Ordering</code>, but only supports a subset of the <code>Ordering</code>s defined by Scala's standard library.</p>
<p>Instead, with Dotty, the <code>tf.math.minimum</code> function can impose an upper bound on tensor element types, consisting of the union type <code>Int | Long | Float | Double</code> to accurately encode the fixed type constraint.</p>
<h3><a class="anchor" aria-hidden="true" id="match-types"></a><a href="#match-types" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Match types</h3>
<p>Dotty's match types provide support for transforming a type into another; it's even possible to define recursive transformations with match types. Tf-dotty makes extensive use of match types to manipulate tensor shapes and indices. For instance, \scala{tf.constant} creates a tensor from a Scala multi-dimensional array. To type this tensor, it needs to know the type of the elements in the array, which it can get from the following match type:</p>
<pre><code class="hljs css language-scala"><span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">Unbox</span>[<span class="hljs-type">S</span>] </span>= <span class="hljs-type">S</span> <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-type">Iterable</span>[t] =&gt; <span class="hljs-type">Unbox</span>[t]
    <span class="hljs-keyword">case</span> <span class="hljs-type">AnyVal</span> =&gt; <span class="hljs-type">S</span>
}
</code></pre>
<p>For instance, <code>Unbox[Seq[Seq[Int]</code> reduces to <code>Int</code>, so we know to type the resulting tensor as a tensor of <code>Int</code>.</p>
<h2><a class="anchor" aria-hidden="true" id="extensions-to-dottys-type-system"></a><a href="#extensions-to-dottys-type-system" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Extensions to Dotty's type system</h2>
<p>tf-dotty also uses a few language features that are not yet part of the official Dotty compiler.</p>
<h3><a class="anchor" aria-hidden="true" id="singleton-operations"></a><a href="#singleton-operations" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Singleton operations</h3>
<p>Dotty has support for <code>scala.compiletime.S</code>, a type which represents the successor of a natural singleton integer type: for instance, the type <code>S[1]</code> reduces to the singleton type <code>2</code>. Implementing tf-dotty has given a motivation for more general arithmetic operations on singleton types, such as addition and multiplication. For instance, <a href="/tf-dotty/docs/reshape">typing the <code>reshape</code> operation</a> requires computing the product of the tensor's dimensions.</p>
<p>This feature was implemented in a fork of Dotty, and <a href="https://github.com/lampepfl/dotty/pull/7628">has since been integrated to the upstream version</a>. The implementation defines a series of abstract types in Dotty's standard library, in the <code>scala.compiletime.ops</code> package. For example, <code>scala.compiletime.ops.int.*</code> provides support for multiplying two singleton <code>Int</code> types, and <code>scala.compiletime.ops.boolean.&amp;&amp;</code> for the conjunction of two singleton <code>Boolean</code> types.</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.compiletime.ops.int._
<span class="hljs-keyword">import</span> scala.compiletime.ops.boolean._

<span class="hljs-keyword">val</span> conjunction: <span class="hljs-literal">true</span> &amp;&amp; <span class="hljs-literal">true</span> = <span class="hljs-literal">true</span>
<span class="hljs-keyword">val</span> multiplication: <span class="hljs-number">3</span> * <span class="hljs-number">5</span> = <span class="hljs-number">15</span>
</code></pre>
<p>Many of these singleton operation types are meant to be used infix (as in <a href="https://www.scala-lang.org/files/archive/spec/2.12/03-types.html#infix-types">SLS § 3.2.8</a>), and are annotated with <a href="scala.annotation.infix"><code>@infix</code></a> accordingly. This annotation means that the notation <code>3 + 2</code> should be used over <code>+[3, 2]</code>. The current implementation of Dotty does not enforce this preference, but annotating the types explicitly can be useful for future Scala 3 tooling.</p>
<p>Since type aliases have the same precedence rules as their term-level equivalents, the operations compose with the expected precedence rules:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.compiletime.ops.int._
<span class="hljs-keyword">val</span> x: <span class="hljs-number">1</span> + <span class="hljs-number">2</span> * <span class="hljs-number">3</span> = <span class="hljs-number">7</span>
</code></pre>
<p>The implementation of this feature chiefly consists of an extension to Dotty's type comparer. When two types are compared, and one of them is a singleton operation type from the <code>scala.compiletime.ops</code> package, the compiler will attempt to constant fold the operation type. If the arguments are singleton types, or can be reduced to singleton types by a constant fold, the compiler can reduce the operation. For instance, in the example above, the type <code>1 + 2 * 3</code> is parsed as <code>+[1, *[2, 3]]</code>, which can be reduced to <code>+[1, 6]</code> by reducing <code>*[2, 3]</code> to <code>6</code>; the addition <code>+[1, 6]</code> can then then be reduced to <code>7</code>.</p>
<p>The singleton operations also need to be reduced when appearing in the scrutinee of a match type, or in the arguments to a type application. By composing singleton operations with match types and type aliases, it is possible to write powerful type-level computations, such as the example below computing the greatest common denominator (GCD) at the type level:</p>
<pre><code class="hljs css language-scala"><span class="hljs-keyword">import</span> scala.compiletime.int.%

<span class="hljs-class"><span class="hljs-keyword">type</span> <span class="hljs-title">GCD</span>[<span class="hljs-type">A</span> &lt;: <span class="hljs-type">Int</span>, <span class="hljs-type">B</span> &lt;: <span class="hljs-type">Int</span>] <span class="hljs-title">&lt;</span></span>: <span class="hljs-type">Int</span> = <span class="hljs-type">B</span> <span class="hljs-keyword">match</span> {
    <span class="hljs-keyword">case</span> <span class="hljs-number">0</span> =&gt; <span class="hljs-type">A</span>
    <span class="hljs-keyword">case</span> _ =&gt; <span class="hljs-type">GCD</span>[<span class="hljs-type">B</span>, <span class="hljs-type">A</span> % <span class="hljs-type">B</span>]
}

<span class="hljs-keyword">val</span> gcd: <span class="hljs-type">GCD</span>[<span class="hljs-number">252</span>, <span class="hljs-number">105</span>] = <span class="hljs-number">21</span>
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="error-singleton-operation"></a><a href="#error-singleton-operation" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>Error</code> singleton operation</h3>
<p>With the ability to write complex type-level computations comes the need for better feedback to the user. Dotty's current implementation of match types leaves them unreduced if reduction is not possible, which may expose implementation details to the caller of a match type. Additionally, there may be cases where inputs to a match type are decidedly erroneous, and a custom compilation error would be desirable.</p>
<p>Dotty already has support for custom compilation error messages for implicit search with the <code>@implicitNotFound</code> annotation, and for inlining with <code>scala.compiletime.error</code>.</p>
<p>To support custom errors in match types, Dotty could add a <code>scala.compiletime.ops.Error</code> type, which can be implemented as another compiletime singleton operation. This type takes a singleton string type, which defines the error message. Unlike other operations, it never returns a value when constant folded by the compiler, but instead throws a type error. An implementation of this is under discussion in <a href="https://github.com/lampepfl/dotty/pull/7951">a PR to Dotty</a>. However, for inclusion into the main branch of Dotty, it still needs more clearly defined semantics of when the error is evaluated by the compiler.</p>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="/tf-dotty/docs/architecture"><span class="arrow-prev">← </span><span>Architecture</span></a><a class="docs-next button" href="/tf-dotty/docs/tensor"><span>Tensor</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#existing-dotty-types">Existing Dotty types</a><ul class="toc-headings"><li><a href="#singleton-types">Singleton types</a></li><li><a href="#union-types">Union types</a></li><li><a href="#match-types">Match types</a></li></ul></li><li><a href="#extensions-to-dottys-type-system">Extensions to Dotty's type system</a><ul class="toc-headings"><li><a href="#singleton-operations">Singleton operations</a></li><li><a href="#error-singleton-operation"><code>Error</code> singleton operation</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="/tf-dotty/" class="nav-home"></a><div><h5>Docs</h5><a href="/tf-dotty/docs/getting-started">Getting Started</a><a href="/tf-dotty/docs/architecture">Architecture</a><a href="/tf-dotty/docs/tensor">Implementation</a><a href="/tf-dotty/docs/contributing">Contributing</a></div><div><h5>More</h5><a href="/tf-dotty/blog">Blog</a><a href="https://github.com/MaximeKjaer/tf-dotty">GitHub</a><a class="github-button" href="https://github.com/MaximeKjaer/tf-dotty" data-icon="octicon-star" data-count-href="/MaximeKjaer/tf-dotty/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>